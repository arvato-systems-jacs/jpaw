package de.jpaw.enumsets;

import de.jpaw.enums.AbstractByteEnumSet
import de.jpaw.enums.AbstractIntEnumSet
import de.jpaw.enums.AbstractLongEnumSet
import de.jpaw.enums.AbstractShortEnumSet
import de.jpaw.enums.AbstractStringEnumSet
import java.util.Iterator
import org.eclipse.xtend.lib.macro.AbstractClassProcessor
import org.eclipse.xtend.lib.macro.Active
import org.eclipse.xtend.lib.macro.TransformationContext
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration
import org.eclipse.xtend.lib.macro.declaration.TypeReference
import org.eclipse.xtend.lib.macro.declaration.Visibility

/** Generates a specific concrete class implementing some EnumSet.
 * The annotated class must extend AbstractEnumSet.
 */
@Active(SetOfEnumProcessor)
annotation SetOfEnum {}

class SetOfEnumProcessor extends AbstractClassProcessor {

    override doTransform(MutableClassDeclaration cls, extension TransformationContext context) {
        val overrideAnno = Override.newAnnotationReference
        var TypeReference tmpRetType
        
        if (cls.extendedClass === null) {
            cls.addError('''Must extend one of the AbstractEnum*Set classes, but does not inherit from any class''')
            return
        }
        switch (cls.extendedClass.type.qualifiedName) {
        case AbstractByteEnumSet.newTypeReference.type.qualifiedName:
            tmpRetType = primitiveByte
        case AbstractShortEnumSet.newTypeReference.type.qualifiedName:
            tmpRetType = primitiveShort
        case AbstractIntEnumSet.newTypeReference.type.qualifiedName:
            tmpRetType = primitiveInt
        case AbstractLongEnumSet.newTypeReference.type.qualifiedName:
            tmpRetType = primitiveLong
        case AbstractStringEnumSet.newTypeReference.type.qualifiedName:
            tmpRetType = string
        default: {        
            cls.addError('''Must extend one of the AbstractEnum*Set classes, but does «cls.extendedClass.type.qualifiedName»''')
            return
            }
        }
        val finalRetType = tmpRetType
        val enumType = cls.extendedClass.actualTypeArguments?.head      
        val iteratorType = Iterator.newTypeReference(enumType) 
        
        cls.final = true
        cls.docComment = '''More boilerplate code, automatically generated by the SetOfEnum active annotation.'''
        cls.addField("VALUES") [
            final = true
            visibility = Visibility::PRIVATE
            type = newArrayTypeReference(enumType)
            initializer = [ '''«toJavaCode(enumType)».values()''' ]  
        ]
        cls.addField("NUMBER_OF_INSTANCES") [
            final = true
            visibility = Visibility::PUBLIC
            type = primitiveInt
            initializer = [ '''VALUES.length; // no simpler way????''' ]  
        ]
        cls.addMethod("getMaxOrdinal") [
            visibility = Visibility::PUBLIC
            returnType = primitiveInt
            final = true
            addAnnotation(overrideAnno)
            body = [ '''
                return NUMBER_OF_INSTANCES;
            ''']
        ]
        cls.addMethod("iterator") [
            visibility = Visibility::PUBLIC
            returnType = iteratorType
            final = true
            addAnnotation(overrideAnno)
            body = [ '''
                return new SetOfEnumsIterator<«toJavaCode(enumType)»>(VALUES, getBitmap());
            ''']
        ]
        cls.addConstructor[
            visibility = Visibility::PUBLIC
            body = [ '''
                super();
            ''']
        ]
        cls.addConstructor[
            visibility = Visibility::PUBLIC
            addParameter("bitmap", finalRetType)
            body = [ '''
                super(bitmap);
            ''']
        ]
        cls.addMethod("of") [
            visibility = Visibility::PUBLIC
            returnType = cls.newTypeReference
            addParameter("args", newArrayTypeReference(enumType))
            varArgs = true
            static = true
            body = [ '''
                return new «toJavaCode(cls.newTypeReference)»(bitmapOf(args));
            ''']
        ]
    }
}